initialize() {
	
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	sigma_i = 1; // area for individulas to mate with might condider 2
	recomb=1e-8;
	sigma_in = 0.5; // i want more of a decrease in fitness when there are too many neighbors!
	
	defineConstant("sigma_M", 0.33); // the meeting interaction term
	defineConstant("K", 1);  // carrying-capacity per unit square (roughly)
	defineConstant("SD", sigma_in);  // sigma_D, the dispersal distance
	defineConstant("SI", sigma_in);  // sigma_I, the spatial interaction distance
	defineConstant("SM", SI);  // sigma_M, the mate choice distance
	defineConstant("L", 4);    // mean lifetime at stationarity
	defineConstant("W", 35.0);  // width and height of the simulated area
	defineConstant("G", 1e8);  // genome length
	defineConstant("FECUN", 1/(L)); // mean fecundity
	defineConstant("RHO", FECUN/((1+FECUN) * K)); // constant in spatial competition function
	
	initializeMutationType("m1", 0.5, "n", 0.0, 1.0);
	initializeMutationType("m2", 0.5, "n", 0.0, 1.0);
	initializeGenomicElementType("g1", c(m1, m2), c(2, 1)); // mutation proportions
	initializeGenomicElement(g1, 0, G-1);
	initializeMutationRate(1e-8);
	initializeRecombinationRate(recomb);
	
	// spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SI * 3); //Distance
	i1.setInteractionFunction("n", 1.0/(2*PI*SI^2), SI);
	
	// mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SM * 3);
	i2.setInteractionFunction("n", 1.0/(2*PI*SM^2), SM);

}

// to make the mutions truly neutral?
fitness(m1) { return 1.0; }
fitness(m2) { return 1.0; }


//why does it avoid the bottom left corner?
reproduction(p1) {
	// choose our nearest neighbor as a mate, within the max distance
	// How to do this by sub-population 
	mate = i2.drawByStrength(individual, 1);
	if (mate.size()) {
		nOff = rpois(1, FECUN);
		for (i in seqLen(nOff)) {
			pos = individual.spatialPosition + rnorm(2, 0, SD); // add dispersal
			if (p1.pointInBounds(pos)) {
				offspring = subpop.addCrossed(individual, mate);
				offspring.setSpatialPosition(p1.pointReflected(pos));
			}
		}
	}
	return;
}

reproduction(p2) {
	// choose our nearest neighbor as a mate, within the max distance
	// How to do this by sub-population 
	mate = i2.drawByStrength(individual, 1);
	if (mate.size()) {
		nOff = rpois(1, FECUN);
		for (i in seqLen(nOff)) {
			pos = individual.spatialPosition + rnorm(2, 0, SD); // add dispersal
			if (p2.pointInBounds(pos)) {
				offspring = subpop.addCrossed(individual, mate);
				offspring.setSpatialPosition(p2.pointReflected(pos));
			}
		}
	}
	return;
}


1 early() {
	sim.addSubpop("p1", asInteger(K * W * W));
	sim.addSubpop("p2", asInteger(K * W * W));
	p1.setSpatialBounds(c(0, 0, W, W));
	p2.setSpatialBounds(c(0, 0, W, W));
	// would it be better to add them on the same plot
	// random initial positions
	for (ind in p1.individuals) {
		ind.setSpatialPosition(p1.pointUniform());
	}
	for (ind in p2.individuals) {
		ind.setSpatialPosition(p2.pointUniform());
	}
	i1.evaluate();
}


early() {
	
	// removing mutations that apear in the wrong population
	muts1 = sim.mutationsOfType(m1);  // newt mutations
	muts2 = sim.mutationsOfType(m2); // snake mutations
	p1.individuals.genomes.removeMutations(muts2);
	p2.individuals.genomes.removeMutations(muts1);
}



early() { //competition within and between populations
	// relate the populations posion/resistance levels with individual interactions and do competetion within a population 
	i1.evaluate(p1);
	i2.evaluate(p2);
	inds_n = p1.individuals;
	inds_s = p2.individuals;
	
	newt_competition = i1.totalOfNeighborStrengths(inds_n); // find number of newt neighbors for each newt
	snake_competition = i2.totalOfNeighborStrengths(inds_s);
	
	// caculating the phenotype, but usinf the exponet to only have postive phenotypes
	// might change with 1 on 1 interaction
	phenotypes_n = exp(inds_n.sumOfMutationsOfType(m1)/10);
	phenotypes_s = exp(inds_s.sumOfMutationsOfType(m2)/10);
	
	// construct phenotypes and fitness effects from QTLs 
	inds_n.z = phenotypes_n;
	inds_s.z = phenotypes_s;
	
	
	inds_n.fitnessScaling = pmin(0.95, 1/(1 + RHO * newt_competition));
	inds_s.fitnessScaling = pmin(0.95, 1/(1 + RHO * snake_competition));
	
	
	// avoid edge effects
	inds_n.fitnessScaling = inds_n.fitnessScaling * pmin(sqrt(inds_n.x/SI), 1.0) * pmin(sqrt(inds_n.y/SI), 1.0) * pmin(sqrt((W - inds_n.x)/SI), 1.0) * pmin(sqrt((W - inds_n.y)/SI), 1.0); // * effects
	inds_s.fitnessScaling = inds_s.fitnessScaling * pmin(sqrt(inds_s.x/SI), 1.0) * pmin(sqrt(inds_s.y/SI), 1.0) * pmin(sqrt((W - inds_s.x)/SI), 1.0) * pmin(sqrt((W - inds_s.y)/SI), 1.0);
	
	
	//Snake and Newt 1on1 interaction how do i do an interaction from nearby????
	//meet = sample(seqLen(p1.individualCount), p2.individualCount, replace=T); //get the snakes that find a newt how can I base this on more newt dence places	
	
	//want to put a higher change on sankes encountering a newt if there are a lot of newts near by
	bounds = p2.spatialBounds;
	//m = rep(0, size(p2.individuals));
	// using snakes to find the newt, do snakes activly look for eatable newts?
	m = float(p2.individualCount); // vector for finding the number of newts near the snake
	//catn(p2.individualCount);
	i = 0;
	// find number of newts near each snake and also choose a random newt from near by for a potental interaction
	for (ind_snake in p2.individuals){
		// does a snake meet a newt 
		
		mPoint = c(ind_snake.x,ind_snake.y);
		newtNeighbors = i1.nearestNeighborsOfPoint(p1, mPoint, count=1000000);
		// sample number of newts baised on a draw from a possion dis
		//catn(length(newtNeighbors));
		if (length(newtNeighbors) > 0){
		//catn(length(newtNeighbors));
			//catn(rpois(1, length(newtNeighbors)));
			newt_meet_snake = sample(newtNeighbors, 1); //newt to interact with snake rpois(n, lambda) n-number of near neighbors and lambda - 1
			//catn(newtNeighbors); // it would be good to choose one newt neighbor to use in the phenotype matching in the outcome section
			//newtNeighbors is an object how do i get the individual out????? I think it should be a vector the same length as the snakes with newt individuals (but what would happen if there is a 2 snakes who go for the same newt?)
			m[i] = length(newtNeighbors); // number of newts near by
			//define interaction
			// chance of eating the newt depends on the phyotype of the snake and the newt get a probblity of eating 
			// if newt get eatten its fitness goes down to 0 
			// how does go through each newt if there is more than one?
			compair_pheno = phenotypes_s[ind_snake.index] - phenotypes_n[newt_meet_snake.index];
			if (compair_pheno < 0){
				outcome_s = 0;}
			if (compair_pheno == 0){
				outcome_s = 1;} //random number selection of alive or dead
			if (compair_pheno > 0){
				outcome_s = compair_pheno;}
			
			ind_snake.fitnessScaling = ind_snake.fitnessScaling + (outcome_s/100); //snake ind_snake
			
			//newt_meet_snake for loop
			for(ind_newt in newt_meet_snake){
				compair_pheno_n = phenotypes_s[ind_snake.index] - phenotypes_n[ind_newt.index];
				if (compair_pheno_n > 0){
					outcome_n = 0;}
				if (compair_pheno_n == 0){
					outcome_n = 1;}
				if (compair_pheno_n < 0){
					outcome_n = compair_pheno_n*(-1);}
				//catn(outcome_n);
				ind_newt.fitnessScaling = ind_newt.fitnessScaling + (outcome_n/100);} //newt 
		}
		if (length(newtNeighbors) == 0){
			m[i] = length(newtNeighbors); // number of newts near by
			outcome_s = 1;
			ind_snake.fitnessScaling = ind_snake.fitnessScaling + (outcome_s/100); //snake ind_snake
		
		}
		
		i = i + 1;
		//m = c(m,length(newtNeighbors));
	
	}
	
	//interactingNeighborCount() getting total number of neighbors 
	//drawByStrength() not an option
	
	outcome_n = rep(1.0, p1.individualCount);
	outcome_s = rep(1.0, p2.individualCount);

}

//Create the different selection areas 

1: late() {
	// to be ready for mate choice
	i2.evaluate(p1);
	i2.evaluate(p2);
}





1000 late() {
	sim.simulationFinished();
}
