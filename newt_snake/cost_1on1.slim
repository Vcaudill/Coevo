initialize() {
	
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	initializeTreeSeq();
	sigma_i = 1; // area for individulas to mate with might condider one for each species (2)
	recomb=1e-8;
	sigma_in = 0.5; // i want more of a decrease in fitness when there are too many neighbors!
	
	//Testing factors 	
	//defineConstant("mu_rate", 1e-8); //just be the snake mu
	defineConstant("snake_mu_rate", 1e-6); //snake mu/newt mu it will me more or less comman than nake	
	defineConstant("newt_mu_rate", 1e-10); //newt mu/ snake mu it will me more or less comman than nake
	defineConstant("snake_mu_effect_sd", 0.05);
	defineConstant("newt_mu_effect_sd", 0.05);
	//defineConstant("msprime_file", "newt_snake/data/both_su_1e-10_nu_1e-10_sue_0.01_nue_0.01.init.trees");//sme 0.05, nme 0.01	
	//defineConstant("msprime_file", "newt_snake/data/both_su_1e-10_nu_1e-10_sue_0.01_nue_0.01.init.trees");
	defineConstant("msprime_file", "newt_snake/data/test_1000_su_1e-10_nu_1e-10_sue_0.1_nue_0.1_.init.trees");
	//defineConstant("msprime_file", "newt_snake/data/both_1000_su_1e-11_nu_1e-11_sue_5.0_nue_5.0_GAlit_FN_2133159248_.init.trees");
	
	total_mut_rate = newt_mu_rate + snake_mu_rate;
	defineConstant("grid_val", 5);
	defineConstant("sigma_M", 0.33); // the meeting interaction term
	defineConstant("K", 1);  // carrying-capacity per unit square (roughly)
	defineConstant("SD", sigma_in);  // sigma_D, the dispersal distance
	defineConstant("SI", sigma_in);  // sigma_I, the spatial interaction distance
	defineConstant("surs", sigma_in);  // surs, the surviver distance
	defineConstant("SM", SI);  // sigma_M, the mate choice distance
	defineConstant("L", 4);    // mean lifetime at stationarity (what is the life times are different for each species?)
	defineConstant("W", 35.0);  // width and height of the simulated area
	defineConstant("H", 1);  // Multiplitive height increase of the simulated area
	defineConstant("G", 1e8);  // genome length
	defineConstant("FECUN", 1/(L)); // mean fecundity
	defineConstant("RHO", FECUN/((1+FECUN) * K)); // constant in spatial competition function
	defineConstant("interaction_rate", 0.05);  // how the interation curve is defined  
	defineConstant("PE", 0.1); //Positive effect snake gets when eating a newt
	defineConstant("w", 10); //the width of the logistic curve, change in phyenotype at any state
	defineConstant("c", 0.0); // is the mean change 2w or 3w 2*w
	defineConstant("simID", getSeed());
	defineConstant("NUMGENS", 200000); // how long to run for
	
	//defineConstant("setCOST", 100); //phenotype cost for newts and snakes
	//
	defineConstant("costmin", 50); //phenotype min cost for newts and snakes most restrictive
	defineConstant("costmax", 250); // least restrictive
	defineConstant("image_location", "newt_snake/data/gradent.png"); // picture location
	
	initializeMutationType("m1", 0.5, "n", 0, newt_mu_effect_sd);
	initializeMutationType("m2", 0.5, "n", 0, snake_mu_effect_sd);
	initializeGenomicElementType("g1", c(m1, m2), c(newt_mu_rate, snake_mu_rate)); // mutation proportions add the proportion (the target mutation rate)
	initializeGenomicElement(g1, 0, G-1);
	
	initializeMutationRate(total_mut_rate); //times genome * G-1 p*mu (1e-10), when I made this too high slim crashed
	initializeRecombinationRate(recomb);
	
	// TODO MAKE THE INTERACTIONS CONSISTENT
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SI * 3); //Distance
	i1.setInteractionFunction("n", 1.0/(2*PI*SI^2), SI);
	
	// snakes
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SM * 3);
	i2.setInteractionFunction("n", 1.0/(2*PI*SM^2), SM);


}

/// FUNCTIONS for log file

//Sectional info

//	snake_sum_ind=summarizeIndividuals(p0.individuals, grid_res, p0.spatialBounds, operation="if (length(individuals)>1)length(individuals); else length(individuals); ", empty=0.0, perUnitArea=T);
//	newt_sum_ind=summarizeIndividuals(p1.individuals, grid_res, p1.spatialBounds, operation="if (length(individuals)>1)length(individuals); else length(individuals); ", empty=0.0, perUnitArea=T);


function (float)summarize_ind_num(o<Subpopulation>$ subpop, i$ grid_res_value, i$ index, s$ sanity)
{
	//counting the number of individuals by the area they are in
	grid_res= c(grid_res_value*H,grid_res_value); //dim(row, column)
	sum_ind=summarizeIndividuals(subpop.individuals, grid_res, subpop.spatialBounds, operation="if (length(individuals)>0)length(individuals); else length(individuals); ", empty=0.0); //, perUnitArea=T
	//catn(sanity+ "   " +index + "    " + sum_ind[index]);
	//catn(cur_index);
	return sum_ind[index];
}

function (float)summarize_mean_pheno(o<Subpopulation>$ subpop, i$ grid_res_value, i$ index, s$ sanity)
{
	//mean phenotype of an area
	grid_res= c(grid_res_value*H,grid_res_value); //dim(row, column)
	sum_ind=summarizeIndividuals(subpop.individuals, grid_res, subpop.spatialBounds, operation="if (length(individuals)>0)mean(individuals.getValue('pheno')); else length(individuals); ", empty=NAN);//, perUnitArea=T
	//catn(sanity+ "   " +index + "    " + sum_ind[index]);
	//catn(cur_index);
	return sum_ind[index];
}

function (float)summarize_sd_pheno(o<Subpopulation>$ subpop, i$ grid_res_value, i$ index, s$ sanity)
{
	//pheno sd of an area
	grid_res= c(grid_res_value*H,grid_res_value); //dim(row, column)
	sum_ind=summarizeIndividuals(subpop.individuals, grid_res, subpop.spatialBounds, operation="if (length(individuals)>1)sd(individuals.getValue('pheno')); else NAN; ", empty=NAN); //, perUnitArea=T
	//catn(sanity+ "   " +index + "    " + sum_ind[index]);
	//catn(cur_index);
	return sum_ind[index];
}

function (float)summarize_max_pheno(o<Subpopulation>$ subpop, i$ grid_res_value, i$ index, s$ sanity)
{
	//max phenotype of an area
	grid_res= c(grid_res_value*H,grid_res_value); //dim(row, column)
	sum_ind=summarizeIndividuals(subpop.individuals, grid_res, subpop.spatialBounds, operation="if (length(individuals)>0)max(individuals.getValue('pheno')); else length(individuals); ", empty=NAN); //, perUnitArea=T
	//catn(sanity+ "   " +index + "    " + sum_ind[index]);
	//catn(cur_index);
	return sum_ind[index];
}

function (float)summarize_min_pheno(o<Subpopulation>$ subpop, i$ grid_res_value, i$ index, s$ sanity)
{
	//the min phenotype of an area 
	grid_res= c(grid_res_value*H,grid_res_value); //dim(row, column)
	sum_ind=summarizeIndividuals(subpop.individuals, grid_res, subpop.spatialBounds, operation="if (length(individuals)>0)min(individuals.getValue('pheno')); else length(individuals); ", empty=NAN);//, perUnitArea=T
	//catn(sanity+ "   " +index + "    " + sum_ind[index]);
	//catn(cur_index);
	return sum_ind[index];
}

function (float)summarize_allele(o<Subpopulation>$ subpop, i$ grid_res_value, i$ index, i$ allele, s$ sanity)
{
	//the min phenotype of an area 
	grid_res= c(grid_res_value*H,grid_res_value); //dim(row, column)
	sum_allele=summarizeIndividuals(subpop.individuals, grid_res, subpop.spatialBounds, operation=paste0("sum(individuals.genomes.containsMutations(sim.mutations[sim.mutations.id == ", allele, "]));")); //, perUnitArea=T
	//catn(sanity+ "   " +index + "    " + sum_ind[index]);
	//catn(cur_index);
	return sum_allele[index];
}

function (float)summarize_allele_eff(o<Subpopulation>$ subpop, i$ grid_res_value, i$ index, f$ allele, s$ sanity)
{
	//the min phenotype of an area 
	grid_res= c(grid_res_value*H,grid_res_value); //dim(row, column)
	sum_allele=summarizeIndividuals(subpop.individuals, grid_res, subpop.spatialBounds, operation=paste0("sum(individuals.genomes.containsMutations(sim.mutations[sim.mutations.id == ", allele, "]));")); //, perUnitArea=T
	//catn(sanity+ "   " +index + "    " + sum_ind[index]);
	//catn(cur_index);
	return sum_allele[index];
}

// to make the mutions truly neutral, what is this doing?
fitness(m1) { return 1.0; }
fitness(m2) { return 1.0; }// when it is gone population size explodes


reproduction(p1) {//newts
	// choose our nearest neighbor as a mate, within the max distance 
	mate = i2.drawByStrength(individual, 1);
	if (mate.size()) {
		nOff = rpois(1, FECUN);
		for (i in seqLen(nOff)) {
			pos = individual.spatialPosition + rnorm(2, 0, SD); // add dispersal
			if (p1.pointInBounds(pos)) {
				offspring = subpop.addCrossed(individual, mate);
				offspring.setSpatialPosition(p1.pointReflected(pos));
				offspring.setValue("snakes_killed",0);
				offspring.setValue("pheno",exp(offspring.sumOfMutationsOfType(m1)/10));//rnorm(1, 3, 2)
			}
		}
	}
	return;
}

reproduction(p0) {//snakes
	// choose our nearest neighbor as a mate, within the max distance
	mate = i2.drawByStrength(individual, 1);
	if (mate.size()) {
		nOff = rpois(1, FECUN);
		for (i in seqLen(nOff)) {
			pos = individual.spatialPosition + rnorm(2, 0, SD); // add dispersal
			if (p0.pointInBounds(pos)) {
				offspring = subpop.addCrossed(individual, mate);
				offspring.setSpatialPosition(p0.pointReflected(pos));
				offspring.setValue("newts_killed",0);
				offspring.setValue("pheno",exp(offspring.sumOfMutationsOfType(m2)/10));//rnorm(1, 3, 2)
			}
		}
	}
	return;
}

// "p2" were repaced with "p0" both are for snakes

1 early() {
	sim.rescheduleScriptBlock(s99, generations=NUMGENS);
	
	//		I will need to use the coalescent simulations for newts and snakes
	//		Then give the "neutral" mutations a selection coefficent
	//		I will also add demographic location
	sim.readFromPopulationFile(msprime_file);
	// sometimes there is a problem with this line and I need to change my directory
	//sim.treeSeqRememberIndividuals(p0.individuals);
	//sim.treeSeqRememberIndividuals(p1.individuals);
	
	p1.setSpatialBounds(c(0, 0, W, W*H)); //newt
	p0.setSpatialBounds(c(0, 0, W, W*H)); //snake
	//	// would it be better to add them on the same plot
	//	// random initial positions
	for (ind in p1.individuals) { //newt
		ind.setSpatialPosition(p1.pointUniform());
		ind.setValue("snakes_killed",0);
		ind.setValue("pheno",exp(ind.sumOfMutationsOfType(m1)/10));//rnorm(1, 3, 2)
	}
	for (ind in p0.individuals) { //snake
		ind.setSpatialPosition(p0.pointUniform());
		ind.setValue("newts_killed",0);
		ind.setValue("pheno",exp(ind.sumOfMutationsOfType(m2)/10));//rnorm(1, 3, 2)
	
	}
	sim.addSubpop("p2", 1);
	p2.setSpatialBounds(c(0, 0, W, W*H));
	sim.addSubpop("p3", 1);
	p3.setSpatialBounds(c(0, 0, W, W*H));
	
	// random initial positions
	for (ind in p2.individuals) {
		ind.setSpatialPosition(c(W/2, (W*H)/2));
	}
	for (ind in p3.individuals) {
		ind.setSpatialPosition(c(W/2, (W*H)/2));
	}
	
	
	//Newt and snake phenotype should start at a similar point
	//Something is not working properly so for now I turned this off
	//catn(mean(p0.individuals.getValue("pheno")) + "    " + mean(p1.individuals.getValue("pheno")));
	
	snake_mean = mean(p0.individuals.getValue("pheno"));
	newt_mean = mean(p1.individuals.getValue("pheno"));
	//defineGlobal("snake_offset", 1-snake_mean);
	//defineGlobal("newt_offset", 1-newt_mean);
	
	defineGlobal("snake_offset", 0);
	defineGlobal("newt_offset", 0);
	
	//catn(mean(exp(-(snake_offset + (p0.individuals.getValue('pheno')/setCOST))^2)) + "    " + mean(exp(-(newt_offset + (p1.individuals.getValue('pheno')/setCOST))^2)));
	
	
	mapImage = Image(image_location);

	//cost_vals = mapImage.floatK * (costmax-costmin) + costmin;
	cost_vals = (mapImage.floatK-min(mapImage.floatK))/(max(mapImage.floatK)-min(mapImage.floatK)) * (costmax-costmin) + costmin;
	
   p1.defineSpatialMap("world", "xy", cost_vals, valueRange=c(50, 250), colors=c('#000000', '#FFFFFF'));
   p0.defineSpatialMap("world", "xy", cost_vals, valueRange=c(50, 250), colors=c('#000000', '#FFFFFF'));
	i1.evaluate();
	i2.evaluate();

}


// removing mutations that apear in the wrong population, is this working/helpful 
//early() {
//muts1 = sim.mutationsOfType(m1);  // newt mutations
//muts2 = sim.mutationsOfType(m2); // snake mutations
//p0.individuals.genomes.removeMutations(muts2);
//p1.individuals.genomes.removeMutations(muts1);
//}


//competition within and between populations
early() {
	// relate the populations posion/resistance levels with individual interactions and do competetion within a population 
	i1.evaluate(p1);
	i2.evaluate(p0);
	inds_n = p1.individuals;
	inds_s = p0.individuals;
	

   newt_mapcost=p1.spatialMapValue("world", inds_n.spatialPosition);
   snake_mapcost=p0.spatialMapValue("world", inds_s.spatialPosition);
   
   
	newt_competition = i1.totalOfNeighborStrengths(inds_n); // find number of newt neighbors for each newt
	snake_competition = i2.totalOfNeighborStrengths(inds_s);// find number of snake neighbors for each snake
	
	
	// construct phenotypes and fitness effects from QTLs 
	inds_n.z = inds_n.getValue('pheno');//phenotypes_n
	inds_s.z = inds_s.getValue('pheno'); //phenotypes_s
	
   
   
	cost_n = exp(-(newt_offset + (inds_n.getValue('pheno')/newt_mapcost))^2);
	cost_s = exp(-(snake_offset + (inds_s.getValue('pheno')/snake_mapcost))^2);
	inds_n.fitnessScaling = (pmin(0.95, 1/(1 + RHO * newt_competition)))*cost_n;
	inds_s.fitnessScaling = (pmin(0.95, 1/(1 + RHO * snake_competition)))*cost_s;
	
	
	// avoid edge effects
	inds_n.fitnessScaling = inds_n.fitnessScaling * pmin(sqrt(inds_n.x/SI), 1.0) * pmin(sqrt(inds_n.y/SI), 1.0) * pmin(sqrt((W - inds_n.x)/SI), 1.0) * pmin(sqrt((W*H - inds_n.y)/SI), 1.0); // * effects
	
	inds_s.fitnessScaling = inds_s.fitnessScaling * pmin(sqrt(inds_s.x/SI), 1.0) * pmin(sqrt(inds_s.y/SI), 1.0) * pmin(sqrt((W - inds_s.x)/SI), 1.0) * pmin(sqrt((W*H - inds_s.y)/SI), 1.0);
	
	
	//Snake and Newt 1on1 interaction
	bounds = p0.spatialBounds;
	
	
	// find number of newts near each snake and choose a random newt from nearby for a potental interaction
	// uniform dist based on the distance (how close they are) if they are going to interact, stepping through each of the newtneighbor and picking which one to eat. p could be 0.1 like 10% chance of snake running into newt 
	//want to put a higher chance on sankes encountering a newt if there are a lot of newts near by
	
	//How many individual newts and snakes are interacting each year
	snake_found_newt = 0;
	newt_found = 0;
	snake_deaths = 0;
	newt_deaths = 0;
	for (ind_snake in p0.individuals){
		// does a snake meet a newt? 
		
		mPoint = c(ind_snake.x,ind_snake.y);
		newtNeighbors = i1.nearestNeighborsOfPoint(p1, mPoint, count=1000000);// could make count smaller (limit the number of newts nearby)
		//catn(length(newtNeighbors)); // figuring out the amount of newt neghbors for each snake
		// sample number based on a combination of how close they are using a uniform distibution 
		if (length(newtNeighbors) > 0){ //need newt to be nearby to eat
			snake_found_newt = snake_found_newt + 1;
			// List of which newts the snake will try to eat. It will take a uniform distribution and a probablity of interacting
			distance = i1.distanceToPoint(newtNeighbors, mPoint);// vector of distances 
			probablity = interaction_rate*exp(-(distance^2)/(2*(surs^2))); //curve of the interaction based on the distance of the newt
			
			newt_meet_snake = newtNeighbors[runif(length(newtNeighbors)) < probablity] ; //list of newts snake will try to eat
			
			
			// then go one newt at a time and see the outcome of the interaction which is dependent on phenotypes (check to make sure newt is still alive)
			for(ind_newt in newt_meet_snake){
				
				//check to see if newt is alive, newt is not eaten by more than one snake 
				if(ind_newt.fitnessScaling > 0){
					newt_found = newt_found + 1;
					//Could the snake eat the newt?
					compair_pheno = inds_s.getValue('pheno')[ind_snake.index] - inds_n.getValue('pheno')[ind_newt.index]; // compairing the snake phentype to the newt phenotype
					
					//Did the snake eat the newt?
					//potential outcomes are death for newt or snake, how do we make the survival curve? 
					prob_of_survive = 1.0/(1+exp(-((compair_pheno-c)/w)));// snakes probablity of survival 
					//catn(prob_of_survive);
					survive = runif(1) < prob_of_survive; //did the snake survive? //one will die for sure 
					
					//Future more selections where there is a chance that both survive or die???
					if(survive==T){
						ind_snake.fitnessScaling = ind_snake.fitnessScaling + PE; //snake with eating newt bonus
						// counting the amount of newts a snake has killed						
						ind_snake.setValue("newts_killed",(ind_snake.getValue("newts_killed")+1));
						
						ind_newt.fitnessScaling = 0; //newt
						newt_deaths = newt_deaths + 1;
					
					}
					if(survive==F){
						ind_snake.fitnessScaling = 0; //snake 
						// counting the amount of snakes a newt has killed
						ind_newt.setValue("snakes_killed",(ind_newt.getValue("snakes_killed")+1));
						snake_deaths = snake_deaths +1;
						break; //break if snake dies
					}
				
				}
			}
			
			
			//What is this doing?
			outcome_n = rep(1.0, p1.individualCount);
			outcome_s = rep(1.0, p0.individualCount);
		
		}
	}
	//Global Varables to look at			
	defineGlobal("snake_found_newt", snake_found_newt);
	defineGlobal("newt_found", newt_found);
	defineGlobal("snake_deaths", snake_deaths);
	defineGlobal("newt_deaths", newt_deaths);
}

//Create the different selection areas (Future)

late(){
	inds_n = p1.individuals;
	inds_s = p0.individuals;

		if (length(inds_n) == 0) {
         cat("No more newts");
         sim.simulationFinished();
       }
       if (length(inds_s) == 0) {
         cat("No more snakes");
         sim.simulationFinished();
       }
}

1: late() {
	// to be ready for mate choice
	i2.evaluate(p1);
	i2.evaluate(p0);


}

// Section about allele caculations?
// slim manual pg 255
late(){
	//	
	//	// get the QTL mutations and their frequencies
	
	m2muts = sim.mutationsOfType(m2); //snake excempt newts might also have this one...
	//catn(m2muts);
	//	m2freqs = sim.mutationFrequencies(NULL, m2muts);
	
	//	// sort those vectors by frequency
	//	o = order(m2freqs, ascending=F);
	//	m2muts = m2muts[o];
	//	m2freqs = m2freqs[o];
	
	//	// get the effect sizes
	
	
	//	m2e0 = m2muts.getValue("e0");
	//	m2e1 = m2muts.getValue("e1");
	
	//	// now output a list of the QTL mutations and their effect sizes
	
	//	catn("\nQTL mutations (f: e0, e1):");
	//	for (i in seqAlong(m2muts))
	//		catn(m2freqs[i] + ": " + m2e0[i] + ", " + m2e1[i]);
	// //finding the number of indivduals with a particular mutation 
	//inds_m2 = inds.countOfMutationsOfType(m2);
	//nds_m3 = inds.countOfMutationsOfType(m3);
}


//Snake a Newt display 
2: early() {
	inds_n = p1.individuals;
	inds_s = p0.individuals;
	
	for (pop in sim.subpopulations) {
		max_z = max(pop.individuals.z);
		for (ind in pop.individuals) {
			hue = 0.66 * (0.1 + ind.z) / (0.1 + max_z);
			if(isNAN(hue)==T)
				hue=0;
			ind.color = rgb2color(hsv2rgb(c(hue+0.000001, 1.0, 1.0)));
		}
	}
	
	// make a map of mean phenotypes
	grid_x = (c(0, (seqLen(21) + 0.5)/21, 1.0) * p1.spatialBounds[2]);
	grid_y = (c(0, (seqLen(31) + 0.5)/31, 1.0) * p1.spatialBounds[3]);
	
	newt_means = matrix(rep(0.0, (length(grid_x)-1) * (length(grid_y)-1)),
		nrow=length(grid_y)-1, ncol=length(grid_x)-1);
	snake_means = matrix(rep(0.0, (length(grid_x)-1) * (length(grid_y)-1)),
		nrow=length(grid_y)-1, ncol=length(grid_x)-1);
	snake_newt = matrix(rep(0.0, (length(grid_x)-1) * (length(grid_y)-1)),
		nrow=length(grid_y)-1, ncol=length(grid_x)-1);
	newt_snake = snake_newt;
	
	for (i in seqLen(length(grid_x)-1)) {
		for (j in seqLen(length(grid_y)-1)) {
			nearby_newts = p1.individuals[
				(p1.individuals.x > grid_x[i])
				& (p1.individuals.x <= grid_x[i+1])
				& (p1.individuals.y > grid_y[j])
				& (p1.individuals.y <= grid_y[j+1])
				];
			
			if (length(nearby_newts) > 0) {
				newt_means[length(grid_y) - j - 2, i] = mean(nearby_newts.z);
			}
			
			nearby_snakes = p0.individuals[
				(p0.individuals.x > grid_x[i])
				& (p0.individuals.x <= grid_x[i+1])
				& (p0.individuals.y > grid_y[j])
				& (p0.individuals.y <= grid_y[j+1])
				];
			
			if (length(nearby_snakes) > 0) {
				snake_means[length(grid_y) - j - 2, i] = mean(nearby_snakes.z);
			}
		
		}
	}
	
	snake_newt = snake_means - newt_means;
	newt_snake = newt_means - snake_means;
	bounds = p0.spatialBounds;
	//cor(phenotypes_n, inds_n.fitnessScaling)
	// I want to find the cor between the phenotype and the fitness scaling for each subsection
	// Problems cor cant work on with matrices - so I might need to make a loop
	// in summarizeIndividuals how does operation and gather work?
	// Can I just gather the different individuals in the sections and then do cor?
	
	grid_res = c(grid_val*H, grid_val);
	
	
	// cov in the early and not late part of slim (ind die between early and late)
	// for this I make any space with 0 or 1 individulas into a cov of 2.0.   
	
	//snake_cov=summarizeIndividuals(p0.individuals, grid_res, p0.spatialBounds, operation="if (length(individuals)>1)cov(individuals.getValue('pheno'), individuals.fitnessScaling); else length(individuals)*0.0; ", empty=0.0);
	//snake_num=summarizeIndividuals(p0.individuals, grid_res, p0.spatialBounds, operation="length(individuals);", empty=0.0);
	//catn(snake_num);
	//catn(snake_cov);
	snake_sum_pheno=summarizeIndividuals(p0.individuals, grid_res, p0.spatialBounds, operation="if (length(individuals)>0)sum(individuals.getValue('pheno')); else length(individuals); ", empty=NAN, perUnitArea=T);
	
	snake_mean_pheno=summarizeIndividuals(p0.individuals, grid_res, p0.spatialBounds, operation="if (length(individuals)>0)mean(individuals.getValue('pheno')); else length(individuals); ", empty=NAN, perUnitArea=F);
	
	snake_sum_ind=summarizeIndividuals(p0.individuals, grid_res, p0.spatialBounds, operation="if (length(individuals)>0)length(individuals); else length(individuals); ", empty=0.0, perUnitArea=F);
	
	
	//newt
	//newt_cov=summarizeIndividuals(p1.individuals, grid_res, p1.spatialBounds, operation="if (length(individuals)>1)cov(individuals.getValue('pheno'), individuals.fitnessScaling); else length(individuals)*0.0;", empty=0.0, perUnitArea=T);
	
	newt_sum_pheno=summarizeIndividuals(p1.individuals, grid_res, p1.spatialBounds, operation="if (length(individuals)>0)sum(individuals.getValue('pheno')); else length(individuals); ", empty=NAN, perUnitArea=T);
	
	newt_mean_pheno=summarizeIndividuals(p1.individuals, grid_res, p1.spatialBounds, operation="if (length(individuals)>0)mean(individuals.getValue('pheno')); else length(individuals); ", empty=NAN, perUnitArea=F);
	
	
	newt_sum_ind=summarizeIndividuals(p1.individuals, grid_res, p1.spatialBounds, operation="if (length(individuals)>0)length(individuals); else length(individuals); ", empty=0.0, perUnitArea=F);
	
	//correlations 	
	newt_mean_pheno=newt_mean_pheno[];
	snake_mean_pheno=snake_mean_pheno[];
	//catn(newt_mean_pheno);
	//catn(snake_mean_pheno);
	u=isFinite(newt_mean_pheno)&isFinite(snake_mean_pheno);
	mean_newt_pheno_By_mean_snake_pheno = cor(c(newt_mean_pheno[u]), c(snake_mean_pheno[u])); // mean should not be devied by the area and the things it gives back should be "nan"
	num_newts_By_num_snakes = cor(c(snake_sum_ind), c(newt_sum_ind));
	sum_newt_pheno_By_num_snake = cor(c(newt_sum_pheno), c(snake_sum_ind));
	sum_snake_pheno_By_num_newt = cor(c(snake_sum_pheno), c(newt_sum_ind));
	sum_newt_pheno_By_num_newt = cor(c(newt_sum_pheno), c(newt_sum_ind));
	sum_snake_pheno_By_snake_newt = cor(c(snake_sum_pheno), c(snake_sum_ind));
	
	defineGlobal("mean_newt_pheno_By_mean_snake_pheno", mean_newt_pheno_By_mean_snake_pheno);
	defineGlobal("num_newts_By_num_snakes", num_newts_By_num_snakes);
	defineGlobal("sum_newt_pheno_By_num_snake", sum_newt_pheno_By_num_snake);
	defineGlobal("sum_snake_pheno_By_num_newt", sum_snake_pheno_By_num_newt);
	defineGlobal("sum_newt_pheno_By_num_newt", sum_newt_pheno_By_num_newt);
	defineGlobal("sum_snake_pheno_By_snake_newt", sum_snake_pheno_By_snake_newt);
	
	
	// maybe it should be transposed?
	// standorize the colors 
	//p1.defineSpatialMap('newts', 'xy', newt_means, interpolate=F,
	//valueRange=range(p1.individuals.z), colors=c("#FFFFFF", "#FF0000"));//"#000000", "#FFFFFF"
	//p0.defineSpatialMap('snakes', 'xy', snake_means, interpolate=F,
	//valueRange=range(p0.individuals.z), colors=c("#FFFFFF", "#0000FF"));//"#000000", "#FFFFFF"
	//p2.defineSpatialMap('snakes-newts', 'xy', snake_newt , interpolate=F,
	//valueRange=range(snake_newt), colors=c("#FFFFFF", "#0000FF"));//more blue more resistance
	
	snake_mean_pheno_calc = summarizeIndividuals(p0.individuals, grid_res, bounds,
		operation="individuals.size();", empty=0.0, perUnitArea=T);
	snake_mean_pheno_calc = snake_mean_pheno_calc / max(snake_mean_pheno_calc);
	//p2.defineSpatialMap("snake_mean_pheno_calc", "xy", snake_mean_pheno_calc, F,
	//range(snake_mean_pheno_calc), c("black", "orange", "red")); //looking at snake mean phenotype by section
	
	newt_mean_pheno_calc = summarizeIndividuals(p1.individuals, grid_res, bounds,
		operation="individuals.size();", empty=0.0, perUnitArea=T);
	newt_mean_pheno_calc = newt_mean_pheno_calc / max(newt_mean_pheno_calc);
	//p3.defineSpatialMap("newt_mean_pheno_calc", "xy", newt_mean_pheno_calc, F,
	//range(newt_mean_pheno_calc), c("black", "orange", "red")); //looking at newt mean phenotype by section
	
	//p2.defineSpatialMap("snake_cov", "xy", snake_cov, F, c(-0.1,0.1), colors=c("red", "white", "blue")); // showing the cov of snakes the range can make the colors lighter and darker depending on the cor values
	
	//p3.defineSpatialMap("newt_cov", "xy", newt_cov, F, c(-0.1,0.1), c("red", "white", "blue")); // showing the cov of newts
}


//files I want to make and now they will be made into log files

1 early() {
	// Log Files
	//log_S.addCustomColumn("",";"); //how to add a log column
	
	inds_n = p1.individuals;
	inds_s = p0.individuals;
	beta_n = cor(inds_n.getValue('pheno'), inds_n.fitnessScaling);
	beta_s = cor(inds_s.getValue('pheno'), inds_s.fitnessScaling);
	defineGlobal("beta_n", beta_n);
	defineGlobal("beta_s", beta_s);
	
	// Top allele information
	muts = sim.mutationsOfType(m1);
	f = sim.mutationFrequencies(p1, muts);
	s = muts.selectionCoeff;
	v = s^2 * f * (1 - f);
	m = muts[whichMax(v)];
	vord = order(v, ascending=F);
	defineGlobal("muts", muts);
	defineGlobal("v", vord);
	
	muts_s = sim.mutationsOfType(m2);
	f_s = sim.mutationFrequencies(p0, muts_s);
	s_s = muts_s.selectionCoeff;
	v_s = s_s^2 * f_s * (1 - f_s);
	m_s = muts_s[whichMax(v_s)];
	vord_s = order(v_s, ascending=F);
	
	// text file
	//mytextfile=outpath+tag+"_GA"+grid_val+grid_val+"_lit_"+"snake_mu_rate_"+snake_mu_rate+ "_newt_mu_rate_"+newt_mu_rate + "_snake_mu_effect_sd_"+ snake_mu_effect_sd +"_newt_mu_effect_sd_" +newt_mu_effect_sd+"_sigma_"+SD+ "_ID_"+seed + "_interaction_rate_" + interaction_rate + "_cost_" + setCOST + "_late_" + NUMGENS + "_.text"; //file name
	mytextfile="~/Desktop/text_file.txt";
	log_t = sim.createLogFile(mytextfile, logInterval=20);
	log_t.addGeneration();
	
	
	log_t.addCustomColumn("Newt_age","mean(p1.individuals.age);");
	log_t.addCustomColumn("Snake_age","mean(p0.individuals.age);");
	log_t.addCustomColumn("Newt_density","p1.individualCount/W^2;");
	log_t.addCustomColumn("Snake_density","p0.individualCount/W^2;");
	log_t.addCustomColumn("Newt_min_Pheno","min(p1.individuals.getValue('pheno'));");
	log_t.addCustomColumn("Newt_max_Pheno","max(p1.individuals.getValue('pheno'));");
	log_t.addCustomColumn("Newt_mean_Pheno","mean(p1.individuals.getValue('pheno'));");
	log_t.addCustomColumn("Newt_sd_Pheno","sd(p1.individuals.getValue('pheno'));");
	log_t.addCustomColumn("Snake_min_Pheno","min(p0.individuals.getValue('pheno'));");
	log_t.addCustomColumn("Snake_max_Pheno","max(p0.individuals.getValue('pheno'));");
	log_t.addCustomColumn("Snake_mean_Pheno","mean(p0.individuals.getValue('pheno'));");
	log_t.addCustomColumn("Snake_sd_Pheno","sd(p0.individuals.getValue('pheno'));");
	log_t.addCustomColumn("Newt_pop_size","size(p1.individuals);");
	log_t.addCustomColumn("Snake_pop_size","size(p0.individuals);");
	log_t.addCustomColumn("mean_newts_eaten","mean(p0.individuals.getValue('newts_killed')/(p0.individuals.age +1));");
	log_t.addCustomColumn("sd_newts_eaten","sd(p0.individuals.getValue('newts_killed')/(p0.individuals.age +1));");
	log_t.addCustomColumn("mean_snakes_eaten","mean(p1.individuals.getValue('snakes_killed')/(p1.individuals.age +1));");
	log_t.addCustomColumn("sd_snakes_eaten","sd(p1.individuals.getValue('snakes_killed')/(p1.individuals.age +1));");
	log_t.addCustomColumn("beta_n","beta_n;");
	log_t.addCustomColumn("beta_s","beta_s;");
	log_t.addCustomColumn("snake_found_newt","snake_found_newt;");
	log_t.addCustomColumn("newt_found","newt_found;");
	log_t.addCustomColumn("snake_deaths","snake_deaths;");
	log_t.addCustomColumn("newt_deaths","newt_deaths;");
	log_t.addCustomColumn(paste0("newt_top_allele_", 1),"muts[v[0]].selectionCoeff;");
	log_t.addCustomColumn(paste0("newt_top_allele_", 2),"muts[v[1]].selectionCoeff;");
	log_t.addCustomColumn(paste0("newt_top_allele_", 3),"muts[v[2]].selectionCoeff;");
	log_t.addCustomColumn("time","clock();");
	
	//phenotype file
	//This is not a log file because I am recording all of the ind each generation and that would require a loop
	
	//myphenotypefile=outpath+tag+"_GA"+grid_val+grid_val+"_litbyind_"+"snake_mu_rate_"+snake_mu_rate+ "_newt_mu_rate_"+newt_mu_rate + "_snake_mu_effect_sd_"+ snake_mu_effect_sd +"_newt_mu_effect_sd_" +newt_mu_effect_sd+"_sigma_"+SD+ "_ID_"+seed + "_cost_" + setCOST + "_interaction_rate_" + interaction_rate + "_late_" + NUMGENS + "_.text"; //file name
	outpath="~/Desktop/";
	myphenotypefile=outpath+"phenotype.txt";
	defineGlobal("myphenotypefile", myphenotypefile);
	myphenotypefileheader="gen" + "    " + "phenotype" + "    " + "fitness" + "    " + "age"+ "    " + "species"+ "    " + "loc_x" + "    " + "loc_y";
	if (sim.generation == 1) {
		
		writeFile(myphenotypefile, myphenotypefileheader , append = T);
		//writing info about the newt "N"		
		myphenotypefileinfo = sim.generation + "    "  + asString(inds_n.getValue("pheno"))+ "    " + asString(inds_n.fitnessScaling)+"    "  +asString(inds_n.age)+ "    " + "N"+ "    " + asString(inds_n.x) + "    " + asString(inds_n.y);
		writeFile(myphenotypefile, myphenotypefileinfo , append = T);
		//writing info about the snakes "S"
		myphenotypefileinfo = sim.generation + "    "  + asString(inds_s.getValue("pheno"))+ "    " + asString(inds_s.fitnessScaling)+"    "  +asString(inds_s.age)+ "    " + "S"+ "    " + asString(inds_s.x) + "    " + asString(inds_s.y);
		writeFile(myphenotypefile, myphenotypefileinfo , append = T);
	
	}
	
	//grid space file
	log = sim.createLogFile("~/Desktop/grid_space.txt", logInterval=10);
	log.addGeneration();
	log_a = sim.createLogFile("~/Desktop/grid_allele.txt", logInterval=10);
	log_a.addGeneration();
	
	
	//loop for the different spaces in the grid 
	//	for (element in 0:(grid_val*grid_val*H-1)){
	//		//summarize_ind_num
	//		log.addCustomColumn(paste0("newt_num_ind_", element), paste0("summarize_ind_num(p1, grid_res_value=grid_val, index=", element, ", sanity='Newt num ind');"));
	//		log.addCustomColumn(paste0("snake_num_ind_", element), paste0("summarize_ind_num(p0, grid_res_value=grid_val, index=", element, ", sanity='Snake num ind');"));
	//		
	//		//summarize_max_pheno
	//		log.addCustomColumn(paste0("newt_max_pheno_", element), paste0("summarize_max_pheno(p1, grid_res_value=grid_val, index=", element, ", sanity='Newt max pheno');"));
	//		log.addCustomColumn(paste0("snake_max_pheno_", element), paste0("summarize_max_pheno(p0, grid_res_value=grid_val, index=", element, ", sanity='Snake max pheno');"));
	//		//summarize_mean_pheno
	//		log.addCustomColumn(paste0("newt_mean_pheno_", element), paste0("summarize_mean_pheno(p1, grid_res_value=grid_val, index=", element, ", sanity='Newt mean pheno');"));
	//		log.addCustomColumn(paste0("snake_mean_pheno_", element), paste0("summarize_mean_pheno(p0, grid_res_value=grid_val, index=", element, ", sanity='Snake mean pheno');"));
	//		//summarize_sd_pheno
	//		log.addCustomColumn(paste0("newt_sd_pheno_", element), paste0("summarize_sd_pheno(p1, grid_res_value=grid_val, index=", element, ", sanity='Newt sd pheno');"));
	//		log.addCustomColumn(paste0("snake_sd_pheno_", element), paste0("summarize_sd_pheno(p0, grid_res_value=grid_val, index=", element, ", sanity='Snake sd pheno');"));
	//		//summarize_min_pheno
	//		log.addCustomColumn(paste0("newt_min_pheno_", element), paste0("summarize_min_pheno(p1, grid_res_value=grid_val, index=", element, ", sanity='Newt min pheno');"));
	//		log.addCustomColumn(paste0("snake_min_pheno_", element), paste0("summarize_min_pheno(p0, grid_res_value=grid_val, index=", element, ", sanity='Snake min pheno');"));
	//		//for loop for top 10 alleles eventually 
	//		k=1;
	//		log_a.addCustomColumn(paste0("newt_allele_", k-1, "_", element), paste0("summarize_allele(p1, grid_res_value=grid_val, index=", element, ", allele=", muts[v[k]].id,", sanity='Newt allele info');"));
	//		log_a.addCustomColumn(paste0("snake_allele_", k-1, "_", element), paste0("summarize_allele(p0, grid_res_value=grid_val, index=", element, ", allele=", muts_s[v_s[k]].id,", sanity='Snake allele info');"));
	//		
	//		//log_a.addCustomColumn(paste0("newt_alleleEFF_", k, "_", element), paste0("summarize_allele_eff(p1, grid_res_value=grid_val, index=", element, ", allele=", muts[v[k]].selectionCoeff,", sanity='Newt allele effect');"));
	//		//log_a.addCustomColumn(paste0("snake_alleleEFF_", k, "_", element), paste0("summarize_allele_eff(p0, grid_res_value=grid_val, index=", element, ", allele=", muts_s[v_s[k]].selectionCoeff,", sanity='Snake allele effect');"));
	//	
	
	//	}
}

2: early(){
	if ((sim.generation % 10) == 0) {
		inds_n = p1.individuals;
		inds_s = p0.individuals;
		//writing info about the newt "N"		
		myphenotypefileinfo = sim.generation + "    "  + asString(inds_n.getValue("pheno"))+ "    " + asString(inds_n.fitnessScaling)+"    "  +asString(inds_n.age)+ "    " + "N"+ "    " + asString(inds_n.x) + "    " + asString(inds_n.y);
		writeFile(myphenotypefile, myphenotypefileinfo , append = T);
		//writing info about the snakes "S"
		myphenotypefileinfo = sim.generation + "    "  + asString(inds_s.getValue("pheno"))+ "    " + asString(inds_s.fitnessScaling)+"    "  +asString(inds_s.age)+ "    " + "S"+ "    " + asString(inds_s.x) + "    " + asString(inds_s.y);
		writeFile(myphenotypefile, myphenotypefileinfo , append = T);
	
	}}

2 early(){
	
	//Cor Log file
	//mycorfile=outpath+tag+"_GA"+grid_val+grid_val+"_cor_"+"snake_mu_rate_"+snake_mu_rate+ "_newt_mu_rate_"+newt_mu_rate + "_snake_mu_effect_sd_"+ snake_mu_effect_sd +"_newt_mu_effect_sd_" +newt_mu_effect_sd+"_sigma_"+SD+ "_ID_"+seed + "_cost_" + setCOST + "_interaction_rate_" + interaction_rate + "_late_" + NUMGENS + "_.text"; //file name
	outpath="~/Desktop/";
	mycorfile=outpath+"cor_file.txt";
	
	log_c = sim.createLogFile(mycorfile, logInterval=10);
	log_c.addGeneration();
	log_c.addCustomColumn("mean_newt_pheno_By_mean_snake_pheno","mean_newt_pheno_By_mean_snake_pheno;");
	log_c.addCustomColumn("num_newts_By_num_snakes","num_newts_By_num_snakes;");
	log_c.addCustomColumn("sum_newt_pheno_By_num_snake","sum_newt_pheno_By_num_snake;");
	log_c.addCustomColumn("sum_snake_pheno_By_num_newt","sum_snake_pheno_By_num_newt;");
	log_c.addCustomColumn("sum_newt_pheno_By_num_newt","sum_newt_pheno_By_num_newt;");
	log_c.addCustomColumn("sum_snake_pheno_By_snake_newt","sum_snake_pheno_By_snake_newt;");

}

s99 10 late() {
	// outpath will need to be defined in the slim call so will the varables and ending time
	//sim.treeSeqOutput(outpath+"mu_rate"+mu_rate+ "newt_mu_rate"+newt_mu_rate + "snake_mu_effect_sd"+ snake_mu_effect_sd +"newt_mu_effect_sd" +newt_mu_effect_sd+"_sigma_"+SD+ "_ID_"+simID + "_late_500000" + "_.trees");
	catn("Done!");
	sim.simulationFinished();
}
