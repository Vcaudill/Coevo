initialize() {
	
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	initializeTreeSeq();
	sigma_i = 1; // area for individulas to mate with might condider one for each species (2)
	recomb=1e-8;
	sigma_in = 0.5; // i want more of a decrease in fitness when there are too many neighbors!
	defineConstant("setpheno", 3.0); //setting all the snakes phenotype to a value
	//Testing factors 	
	defineConstant("snake_mu_rate", 0); //snake mu
	defineConstant("newt_mu_rate", 1e-6); //newt mu/ 
	defineConstant("snake_mu_effect_sd", 0);
	defineConstant("newt_mu_effect_sd", 0.3);
	defineConstant("msprime_file", "newt_snake/data/test_1000_su_1e-10_nu_1e-10_sue_0.1_nue_0.1_.init.trees");
	
	
	total_mut_rate = newt_mu_rate + snake_mu_rate;
	defineConstant("sigma_M", 0.33); // the meeting interaction term
	defineConstant("K", 1);  // carrying-capacity per unit square (roughly)
	defineConstant("SD", sigma_in);  // sigma_D, the dispersal distance
	defineConstant("SI", sigma_in);  // sigma_I, the spatial interaction distance
	defineConstant("surs", sigma_in);  // surs, the surviver distance
	defineConstant("SM", SI);  // sigma_M, the mate choice distance
	defineConstant("L", 4);    // mean lifetime at stationarity (what id the life times are different for each species?)
	defineConstant("W", 35.0);  // width and height of the simulated area
	defineConstant("G", 1e8);  // genome length
	defineConstant("FECUN", 1/(L)); // mean fecundity
	defineConstant("RHO", FECUN/((1+FECUN) * K)); // constant in spatial competition function
	defineConstant("interaction_rate", 0.20);  // how the interation curve is defined  
	defineConstant("PE", 0.1); //Positive effect snake gets when eating a newt
	defineConstant("w", 10); //the width of the logistic curve, change in phyenotype at any state
	defineConstant("c", 0.0); // is the mean change 2w or 3w 2*w
	defineConstant("simID", getSeed());
	
	
	initializeMutationType("m1", 0.5, "n", 0, newt_mu_effect_sd);
	initializeMutationType("m2", 0.5, "n", 0, snake_mu_effect_sd);
	initializeGenomicElementType("g1", c(m1, m2), c(newt_mu_rate, snake_mu_rate)); // mutation proportions add the proportion (the target mutation rate)
	initializeGenomicElement(g1, 0, G-1);
	
	initializeMutationRate(total_mut_rate); //times genome * G-1 p*mu (1e-10), when I made this too high slim crashed
	initializeRecombinationRate(recomb);


}

// to make the mutions truly neutral, what is this doing?
fitness(m1) { return 1.0; }
fitness(m2) { return 1.0; }// when it is gone population size explodes


reproduction(p1) {//newts
	// choose our nearest neighbor as a mate, within the max distance 
	mate = subpop.sampleIndividuals(1);
	if (mate.size()) {
		nOff = rpois(1, FECUN);
		for (i in seqLen(nOff)) {
			pos = individual.spatialPosition + rnorm(2, 0, SD); // add dispersal
			if (p1.pointInBounds(pos)) {
				offspring = subpop.addCrossed(individual, mate);
				offspring.setSpatialPosition(p1.pointReflected(pos));
				offspring.setValue("snakes_killed",0);
				offspring.setValue("pheno",exp(offspring.sumOfMutationsOfType(m1)/10));
			}
		}
	}
	return;
}

reproduction(p0) {//snakes
	// choose our nearest neighbor as a mate, within the max distance
	mate = subpop.sampleIndividuals(1);
	if (mate.size()) {
		nOff = rpois(1, FECUN);
		for (i in seqLen(nOff)) {
			pos = individual.spatialPosition + rnorm(2, 0, SD); // add dispersal
			if (p0.pointInBounds(pos)) {
				offspring = subpop.addCrossed(individual, mate);
				offspring.setSpatialPosition(p0.pointReflected(pos));
				offspring.setValue("newts_killed",0);
				offspring.setValue("pheno", setpheno); //exp(offspring.sumOfMutationsOfType(m2)/10)
			}
		}
	}
	return;
}
// "p2" were repaced with "p0" both are for snakes

1 early() {
	//		I will need to use the coalescent simulations for newts and snakes
	//		Then give the "neutral" mutations a selection coefficent
	//		I will also add demographic location
	sim.readFromPopulationFile(msprime_file);
	// sometimes there is a problem with this line and I need to change my directory
	//sim.treeSeqRememberIndividuals(p0.individuals);
	//sim.treeSeqRememberIndividuals(p1.individuals);
	
	p1.setSpatialBounds(c(0, 0, W, W)); //newt
	p0.setSpatialBounds(c(0, 0, W, W)); //snake
	//	// would it be better to add them on the same plot
	//	// random initial positions
	for (ind in p1.individuals) {
		ind.setSpatialPosition(p1.pointUniform());
		ind.setValue("snakes_killed",0);
		ind.setValue("pheno",exp(ind.sumOfMutationsOfType(m1)/10));
	}
	for (ind in p0.individuals) {
		ind.setSpatialPosition(p0.pointUniform());
		ind.setValue("newts_killed",0);
		ind.setValue("pheno",setpheno); //exp(offspring.sumOfMutationsOfType(m2)/10)
	
	}
	sim.addSubpop("p2", 1);
	p2.setSpatialBounds(c(0, 0, W, W));
	sim.addSubpop("p3", 1);
	p3.setSpatialBounds(c(0, 0, W, W));
	
	// random initial positions
	for (ind in p2.individuals) {
		ind.setSpatialPosition(c(W/2, W/2));
	}
	for (ind in p3.individuals) {
		ind.setSpatialPosition(c(W/2, W/2));
	}
}



//competition within and between populations
early() {
	// relate the populations posion/resistance levels with individual interactions and do competetion within a population 
	
	inds_n = p1.individuals;
	inds_s = p0.individuals;
	
	
	// construct phenotypes and fitness effects from QTLs 
	inds_n.z = inds_n.getValue('pheno');//phenotypes newt
	inds_s.z = inds_s.getValue('pheno'); //phenotypes snake
	
	inds_n.fitnessScaling = pmin(0.95, 1/(1 + RHO * p1.individualCount/(W^2)));
	inds_s.fitnessScaling = pmin(0.95, 1/(1 + RHO * p0.individualCount/(W^2)));
	
	//Snake and Newt 1on1 interaction
	// find number of newts near each snake and choose a random newt from nearby for a potental interaction
	// uniform dist based on the distance (how close they are) if they are going to interact, stepping through each of the newtneighbor and picking which one to eat. p could be 0.1 like 10% chance of snake running into newt 
	//want to put a higher chance on sankes encountering a newt if there are a lot of newts near by
	
	//How many individual newts and snakes are interacting each year
	snake_found_newt = 0;
	newt_found = 0;
	snake_deaths = 0;
	newt_deaths = 0;
	for (ind_snake in p0.individuals){
		// does a snake meet a newt? 		
		numNeighbors = rbinom(1, p1.individualCount, (interaction_rate*2*PI*surs^2)/W^2);
		// Has a snake 
		if (numNeighbors > 0){ //need newt to be nearby to eat
			snake_found_newt = snake_found_newt + 1;
			newt_meet_snake = p1.sampleIndividuals(numNeighbors) ; //list of newts snake will try to eat
			
			// then go one newt at a time and see the outcome of the interaction which is dependent on phenotypes (check to make sure newt is still alive)
			for(ind_newt in newt_meet_snake){
				
				//check to see if newt is alive, newt is not eaten by more than one snake 
				if(ind_newt.fitnessScaling > 0){
					newt_found = newt_found + 1;
					//Could the snake eat the newt?
					compair_pheno = inds_s.getValue('pheno')[ind_snake.index] - inds_n.getValue('pheno')[ind_newt.index]; // compairing the snake phentype to the newt phenotype 
					
					//Did the snake eat the newt?
					//potential outcomes are death for newt or snake, how do we make the survival curve? 
					prob_of_survive = 1.0/(1+exp(-((compair_pheno-c)/w)));// snakes probablity of survival 
					//catn(prob_of_survive);
					survive = runif(1) < prob_of_survive; //did the snake survive? //one will die for sure 
					
					//Future more selections where there is a chance that both survive or die???
					if(survive==T){
						ind_snake.fitnessScaling = ind_snake.fitnessScaling + PE; //snake with eating newt bonus
						// counting the amount of newts a snake has killed						
						ind_snake.setValue("newts_killed",(ind_snake.getValue("newts_killed")+1));
						
						ind_newt.fitnessScaling = 0; //newt
						newt_deaths = newt_deaths + 1;
					
					}
					if(survive==F){
						ind_snake.fitnessScaling = 0; //snake 
						// counting the amount of snakes a newt has killed
						ind_newt.setValue("snakes_killed",(ind_newt.getValue("snakes_killed")+1));
						snake_deaths = snake_deaths +1;
						break; //break if snake dies
					}
				
				}
			}
			
			
			//What is this doing?
			outcome_n = rep(1.0, p1.individualCount);
			outcome_s = rep(1.0, p0.individualCount);
		
		}
	}
	//Global Varables to look at			
	defineGlobal("snake_found_newt", snake_found_newt);
	defineGlobal("newt_found", newt_found);
	defineGlobal("snake_deaths", snake_deaths);
	defineGlobal("newt_deaths", newt_deaths);
}

//Create the different selection areas (Future)


//Snake a Newt display 
1: late() {
	for (pop in sim.subpopulations) {
		max_z = max(pop.individuals.z);
		for (ind in pop.individuals) {
			hue = 0.66 * (0.1 + ind.z) / (0.1 + max_z);
			if(isNAN(hue)==T)
				hue=0;
			ind.color = rgb2color(hsv2rgb(c(hue+0.000001, 1.0, 1.0)));
		}
	}
	
	// make a map of mean phenotypes
	grid_x = (c(0, (seqLen(21) + 0.5)/21, 1.0) * p1.spatialBounds[2]);
	grid_y = (c(0, (seqLen(31) + 0.5)/31, 1.0) * p1.spatialBounds[3]);
	
	newt_means = matrix(rep(0.0, (length(grid_x)-1) * (length(grid_y)-1)),
		nrow=length(grid_y)-1, ncol=length(grid_x)-1);
	snake_means = matrix(rep(0.0, (length(grid_x)-1) * (length(grid_y)-1)),
		nrow=length(grid_y)-1, ncol=length(grid_x)-1);
	snake_newt = matrix(rep(0.0, (length(grid_x)-1) * (length(grid_y)-1)),
		nrow=length(grid_y)-1, ncol=length(grid_x)-1);
	newt_snake = snake_newt;
	
	for (i in seqLen(length(grid_x)-1)) {
		for (j in seqLen(length(grid_y)-1)) {
			nearby_newts = p1.individuals[
				(p1.individuals.x > grid_x[i])
				& (p1.individuals.x <= grid_x[i+1])
				& (p1.individuals.y > grid_y[j])
				& (p1.individuals.y <= grid_y[j+1])
				];
			
			if (length(nearby_newts) > 0) {
				newt_means[length(grid_y) - j - 2, i] = mean(nearby_newts.z);
			}
			
			nearby_snakes = p0.individuals[
				(p0.individuals.x > grid_x[i])
				& (p0.individuals.x <= grid_x[i+1])
				& (p0.individuals.y > grid_y[j])
				& (p0.individuals.y <= grid_y[j+1])
				];
			
			if (length(nearby_snakes) > 0) {
				snake_means[length(grid_y) - j - 2, i] = mean(nearby_snakes.z);
			}
		
		}
	}
	
	snake_newt = snake_means - newt_means;
	newt_snake = newt_means - snake_means;
	
	
	// maybe it should be transposed?
	// standorize the colors 
	p1.defineSpatialMap('newts', 'xy', newt_means, interpolate=F,
		valueRange=range(p1.individuals.z), colors=c("#FFFFFF", "#FF0000"));//"#000000", "#FFFFFF"
	p0.defineSpatialMap('snakes', 'xy', snake_means, interpolate=F,
		valueRange=range(p0.individuals.z), colors=c("#FFFFFF", "#0000FF"));//"#000000", "#FFFFFF"
	p2.defineSpatialMap('snakes-newts', 'xy', snake_newt , interpolate=F,
		valueRange=range(snake_newt), colors=c("#FFFFFF", "#0000FF"));//more blue more resistance
	p3.defineSpatialMap('newts-snakes', 'xy', newt_snake , interpolate=F,
		valueRange=range(newt_snake), colors=c("#FFFFFF", "#FF0000"));//more red more toxic
}

// The varabales that I want to collect from slim 

1 early(){	
	inds_n = p1.individuals;
	inds_s = p0.individuals;
	
	myFN="test1";
	mytextfile="~/Desktop/data/test_"+"snake_mu_rate_"+snake_mu_rate+ "_newt_mu_rate_"+newt_mu_rate + "_snake_mu_effect_sd_"+ snake_mu_effect_sd +"_newt_mu_effect_sd_" +newt_mu_effect_sd+"_sigma_"+SD+ "_FN_"+myFN+ "_ID_"+simID + "_snakesetpheno_" + setpheno + "_interaction_rate_" + interaction_rate + "_late_1000" + "_.text";
	
	myphenotypefile="~/Desktop/data/byind_"+"snake_mu_rate_"+snake_mu_rate+ "_newt_mu_rate_"+newt_mu_rate + "_snake_mu_effect_sd_"+ snake_mu_effect_sd +"_newt_mu_effect_sd_" +newt_mu_effect_sd+"_sigma_"+SD+ "_FN_"+myFN+ "_ID_"+simID + "_snakesetpheno_" + setpheno + "_interaction_rate_" + interaction_rate + "_late_1000" + "_.text";
	
	
	// making the name into global varables
	defineGlobal("mytextfile", mytextfile);
	defineGlobal("myphenotypefile", myphenotypefile);
	
	
	beta_n = cor(inds_n.getValue('pheno'), inds_n.fitnessScaling);
	beta_s = cor(inds_s.getValue('pheno'), inds_s.fitnessScaling);
	
	mytextfileheader="gen" + "    " + "Newt_age" + "    " + "Snake_age" + "    " + "Newt_density"+ "    " + "Snake_density" + "    " + "Newt_min_Pheno" + "    " + "Newt_max_Pheno" + "    " + "Newt_mean_Pheno" + "    " + "Newt_sd_Pheno" + "    " + "Snake_min_Pheno" + "    " + "Snake_max_Pheno"+ "    " + "Snake_mean_Pheno" + "    " + "Snake_sd_Pheno" + "    " + "Newt_pop_size" +
		"    " +"Snake_pop_size"+"    "+ "mean_newts_eaten"+"    "+ "sd_newts_eaten"+"    "+ "mean_snakes_eaten"+"    "+ "sd_snakes_eaten" +"    "+ "beta_n" + "    " + "beta_s" + "    " + "snake_found_newt" + "    "+ "newt_found"+ "    "+ "snake_deaths" + "    "+ "newt_deaths"+ "    " + "time";
	
myphenotypefileheader="gen" + "    " + "phenotype" + "    " + "fitness" + "    " + "age";
	
	mytextfileinfo = sim.generation + "    "  + mean(p1.individuals.age) + "    " + mean(p0.individuals.age) + "    " + p1.individualCount/W^2 + "    " + p0.individualCount/W^2 + "    " + min(inds_n.getValue("pheno")) + "    " + max(inds_n.getValue("pheno")) + "    " + mean(inds_n.getValue("pheno")) + "    " + sd(inds_n.getValue("pheno")) + "    " + min(inds_s.getValue("pheno")) + "    " + max(inds_s.getValue("pheno")) + "    " + mean(inds_s.getValue("pheno")) + "    " + sd(inds_s.getValue("pheno")) + "    " + size(p1.individuals)+"    "+ size(p0.individuals) + "    " + mean(inds_s.getValue("newts_killed")/(inds_s.age +1)) + "    " + sd(inds_s.getValue("newts_killed")/(inds_s.age +1)) + "    " + mean(inds_n.getValue("snakes_killed")/(inds_n.age +1)) + "    " + sd(inds_n.getValue("snakes_killed")/(inds_n.age +1)) + "    " + beta_n + "    "+ beta_s + "    " + snake_found_newt + "    "+ newt_found+ "    "+ snake_deaths + "    "+ newt_deaths + "    " + clock();
	
	
	
	if (sim.generation == 1) {
		catn(mytextfileheader);
		catn(mytextfileinfo);
		
		writeFile(mytextfile, mytextfileheader, append = T);
		writeFile(mytextfile, mytextfileinfo , append = T);

		writeFile(myphenotypefile, myphenotypefileheader , append = T);
		myphenotypefileinfo = sim.generation + "    "  + asString(inds_n.getValue("pheno"))+ "    " + asString(inds_n.fitnessScaling)+"    "  +asString(inds_n.age);
		writeFile(myphenotypefile, myphenotypefileinfo , append = T);
	
	}
}

early(){ //caculating the selection coefficents
	inds_n = p1.individuals;
	inds_s = p0.individuals;
	
	
	beta_n = cor(inds_n.getValue('pheno'), inds_n.fitnessScaling);
	beta_s = cor(inds_s.getValue('pheno'), inds_s.fitnessScaling);
	defineGlobal("beta_n", beta_n);
	defineGlobal("beta_s", beta_s);

}

2: late() {
	inds_n = p1.individuals;
	inds_s = p0.individuals;
	
	
	if ((sim.generation % 1) == 0) {
		mytextfileinfo = sim.generation + "    "  + mean(p1.individuals.age) + "    " + mean(p0.individuals.age) + "    " + p1.individualCount/W^2 + "    " + p0.individualCount/W^2 + "    " + min(inds_n.getValue("pheno")) + "    " + max(inds_n.getValue("pheno")) + "    " + mean(inds_n.getValue("pheno")) + "    " + sd(inds_n.getValue("pheno")) + "    " + min(inds_s.getValue("pheno")) + "    " + max(inds_s.getValue("pheno")) + "    " + mean(inds_s.getValue("pheno")) + "    " + sd(inds_s.getValue("pheno")) + "    " + size(p1.individuals)+"    "+ size(p0.individuals) + "    " + mean(inds_s.getValue("newts_killed")/(inds_s.age +1)) + "    " + sd(inds_s.getValue("newts_killed")/(inds_s.age +1)) + "    " + mean(inds_n.getValue("snakes_killed")/(inds_n.age +1)) + "    " + sd(inds_n.getValue("snakes_killed")/(inds_n.age +1)) + "    " + beta_n + "    "+ beta_s + "    " + snake_found_newt + "    "+ newt_found+ "    "+ snake_deaths + "    "+ newt_deaths + "    " + clock();
		catn(sim.generation + "    "  + mean(inds_n.getValue("pheno")));
		writeFile(mytextfile, mytextfileinfo , append = T);
	
	}
}

2: early(){
	inds_n = p1.individuals;
	inds_s = p0.individuals;
	myphenotypefileinfo = sim.generation + "    "  + asString(inds_n.getValue("pheno"))+ "    " + asString(inds_n.fitnessScaling)+"    "  +asString(inds_n.age);
	writeFile(myphenotypefile, myphenotypefileinfo , append = T);
}

1000 late() {
	// outpath will need to be defined in the slim call so will the varables and ending time
	//outpath="~/Desktop/";
	//myFN="test1";
	//sim.treeSeqOutput(outpath+"snake_mu_rate"+snake_mu_rate+ "_newt_mu_rate_"+newt_mu_rate + "_snake_mu_effect_sd_"+ snake_mu_effect_sd +"_newt_mu_effect_sd_" +newt_mu_effect_sd+"_sigma_"+SD+ "_FN_"+myFN+ "_ID_"+simID + "_late_100000" + "_.trees");
	catn("Done!");
	sim.simulationFinished();
}
